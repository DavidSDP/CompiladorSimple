package analisisSintactico;

import java_cup.runtime.*;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import analisisSemantico.simbolos.*;

terminal    String			tclass, tipoVar, tipoVoid, llaveIzq, llaveDer;
terminal    String			igual, puntocoma, coma, parenIzq, parenDer;
terminal	String			comparador, opLogico, booleano, opSuma, opProd;
terminal	String			string;
terminal	String			numero;
terminal	String			id;

non terminal	SimboloPrograma		programa;
non terminal	SimboloClase		clase;
non terminal	SimboloCuerpo		cuerpo;
non terminal	SimboloElemento		elemento;
non terminal	SimboloAsignacion	asignacion;
non terminal  	SimboloFactor		factor;
non terminal	SimboloOperacion	Operacion;
non terminal	SimboloOperacion	Operacion1;
non terminal	SimboloOperacion	Operacion2;
non terminal	SimboloOperacion	Operacion3;
non terminal  	SimboloFuncionInvk	funcionInvk;
non terminal	SimboloFuncionDef	funcionDef;
non terminal	SimboloFuncionDecl	funcionDecl;
non terminal	SimboloArgs			args;
non terminal	SimboloArgs			nextArg;
non terminal	SimboloContenido	contenido;
non terminal	SimboloParams		params;
non terminal	SimboloParams		nextParam;

start with programa;

programa ::=  clase:c	{: RESULT = new SimboloPrograma(c); :}
			;
			
clase	::=	tclass:t id:i llaveIzq cuerpo:c llaveDer {: RESULT = new SimboloClase(t,i,c); :}
			;
			
cuerpo ::= cuerpo:c elemento:e 	{: RESULT = new SimboloCuerpo(c,e); :}
			|				{: RESULT = null; :}
			;
			
elemento ::= asignacion:a 		{: RESULT = new SimboloElemento(a); :}
			| funcionDecl:f		{: RESULT = new SimboloElemento(f); :}
			| clase:c			{: RESULT = new SimboloElemento(c); :}
			;
			
asignacion ::= tipoVar:t id:i igual Operacion:o puntocoma 	{: RESULT = new SimboloAsignacion(t,i,o); :}
			| tipoVar:t id:i puntocoma 						{: RESULT = new SimboloAsignacion(t,i); :}
			| id:i igual Operacion:o puntocoma 				{: RESULT = new SimboloAsignacion(i,o); :}
			;

funcionDecl ::= tipoVoid:t funcionDef:f				{: RESULT = new SimboloFuncionDecl(t,f); :}
			| tipoVar:t funcionDef:f				{: RESULT = new SimboloFuncionDecl(t,f); :}
			;

funcionDef ::= id:i parenIzq args:a parenDer llaveIzq contenido:c llaveDer {: RESULT = new SimboloFuncionDef(i,a,c); :}
			;
		
funcionInvk ::= id:i parenIzq params:p parenDer {: RESULT = new SimboloFuncionInvk(i,p); :}
		;
			
args ::= tipoVar:t id:i nextArg:n			{: RESULT = new SimboloArgs(t,i,n); :}
		| 									{: RESULT = null; :}
		;

nextArg ::= coma tipoVar:t id:i nextArg:n	{: RESULT = new SimboloArgs(t,i,n); :}
		|									{: RESULT = null; :}
		;
		
contenido ::= contenido:c asignacion:a				{: RESULT = new SimboloContenido(c,a); :}
			| contenido:c funcionInvk:f puntocoma 	{: RESULT = new SimboloContenido(c,f); :}
			| 										{: RESULT = null; :}
			;
		
Operacion ::= Operacion1:o				{: RESULT = new SimboloOperacion(o); :}
		| Operacion:o opSuma:s factor:f	{: RESULT = new SimboloOperacion(o,s,f); :}
		;
	
Operacion1 ::= Operacion2:o					{: RESULT = new SimboloOperacion(o); :}
		| Operacion1:o opProd:p factor:f	{: RESULT = new SimboloOperacion(o,p,f); :}
		;
		
Operacion2 ::= Operacion3:o						{: RESULT = new SimboloOperacion(o); :}
		| Operacion2:o comparador:c factor:f 	{: RESULT = new SimboloOperacion(o,c,f); :}
		;
		
Operacion3 ::= factor:f 					{: RESULT = new SimboloOperacion(f); :}
		| Operacion3:o opLogico:l factor:f	{: RESULT = new SimboloOperacion(o,l,f); :}
		;
	
factor ::= id:i 						{: RESULT = new SimboloFactor(i); :}
		| numero:n 						{: RESULT = new SimboloFactor(n); :}
		| booleano:b					{: RESULT = new SimboloFactor(b); :}
		| string:s						{: RESULT = new SimboloFactor(s); :}
		| funcionInvk:f					{: RESULT = new SimboloFactor(f); :}
		| parenIzq Operacion:o parenDer {: RESULT = new SimboloFactor(o); :}
		;
		
params ::= Operacion:o nextParam:n		{: RESULT = new SimboloParams(o,n); :}
		| 								{: RESULT = null; :}
		;

nextParam ::= coma Operacion:o nextParam:n 	{: RESULT = new SimboloParams(o,n); :}
			| 								{: RESULT = null; :}
			;